# PHILIBERT_BLDC_Motor_Control

This repository is about BLDC motor control with FOC control.
I’m using the pack P-NUCLEO-IHM03 from ST. It’s composed of : 
- An STM32G431RB control board
- An IHM16M1 power board
- A GBM2804H-100T sensorless BLDC motor
- A 12V power supply


**I. NUCLEO-G431RB Control Board**

The NUCLEO-G431RB board is a development board equipped with a 32-bit STM32G431RB microcontroller, powered by 5V via a micro-USB port. This port also allows for programming and debugging through STLink V3E. The board includes ST Morpho connectors for connecting other ST boards and offers LEDs, as well as Reset and User buttons for debugging.

The ARM Cortex-M4 microcontroller operates up to 170 MHz and has 128 KB of Flash, 32 KB of SRAM, and interfaces such as USART, SPI, ADC, and timers. This board provides high performance for control and calculations with low power consumption, ideal for embedded applications like motor control.

**II. X-NUCLEO-IHM16M1 Power Board**

The X-NUCLEO-IHM16M1 board is a power board for controlling BLDC/PMSM motors. It uses an STSPIN830 driver for 3-phase brushless motors and connects to the control board via ST Morpho pins.

Powered by 12V, it provides the necessary power for the motor and integrates protections against voltage and current failures. LEDs on the board indicate motor status and potential errors, ensuring reliable power supply and adequate protection.

**III. GBM2804H-100T BLDC Motor**

The GBM2804H-100T BLDC motor is used for its compact size and good performance. It operates with a 12V power supply and a nominal current of 0.8A. It can reach a maximum speed of 2180 RPM and a maximum torque of 0.981 N.m. The stator resistance is 5.29? and the inductance is 1.058mH. It has 7 pole pairs, a key specification for the project.

**IV. AS5048A Magnetic Encoder**

The AS5048A magnetic encoder is a 360° angular position sensor developed to measure motor rotation. It provides angular position data using a Hall effect sensor to detect the magnetic field generated by a magnet attached to the motor. The encoder offers a 14-bit resolution, allowing for high-precision angle measurements. It communicates via an SPI interface, facilitating integration with control systems. It can provide real-time data with a high sampling frequency, crucial for motor control.

**V. Softwares installation**
- STM32Cube IDE v1.15.0: An integrated development environment designed for STM32 microcontrollers and microprocessors. This is the IDE I use to write C code and flash it onto the board.

- MotorControl Workbench v6.1.2 (MCSDK): A high-level software that helps test, control, and generate code for the board. In this software, you can create the project associated with the used microcontroller or use an example. When generating the code, a folder is automatically created, an .ioc file can be generated by another complementary software (STM32 Cube MX), and finally, the code can be opened in the IDE to be flashed.

- STM32Cube MX v6.6.0: A graphical tool allowing you to configure the board and generate code initializing the selected peripherals. It also manages embedded software packages (STM32G4 v1.5.1). This tool is also integrated into STM32Cube IDE but can also be used separately from the IDE, especially when creating the project.

- STM32Cube Firmware G4 v1.5.1: A package composed of the STM32Cube hardware abstraction layer (HAL) and specific APIs (analog APIs, math accelerators like CORDIC), making it particularly suitable for motor control applications.

- ST-LINK Server v2.1.1: An application allowing you to share the debugging interface between an ST-LINK board and the debugging tool on the IDE.

- STSW-LINK007 v3.15.6: The firmware update application for the control board using ST-LINK via the USB port.

- STM32 Cube Monitor: A software that displays variables graphically by connecting directly via STLink. It allows for visualizing the temporal evolution of chosen variables when compiling the code (not in debugging mode).

**VI. Workflow**
In Motor Control Workbench
* Create a project, name it, and choose the configuration and selected boards.
* Verify the various project parameters (voltage, current, PWM frequency, motor characteristics, etc.).
* Save, generate the project, and open it with STM32 CUBE MX.
In STM32 Cube MX
* Configure the peripherals, GPIOs, timers, and other necessary elements for the project (here, only the SPI connection and the output for NSS are needed).
* Save the configuration, generate the code, and open it in STM32 Cube IDE.
In STM32 Cube IDE
* Write code in the designated areas (mainly in the tasks.c file).
* Build and then debug the code (check the debugger configuration before starting the debug process).
* Flash the board with the code by clicking RUN.
In Motor Pilot
* Ensure there are no errors.
* Verify that the motor runs at the correct speed and in the correct direction.
In STM32 Cube Monitor
* Start the acquisition and visualize the temporal evolution of the variables on the graph.

**VII. How to use the code**
I only modified the "tasks.c" file, as it contains the useful code. 
There is some commented-out code in the "main.c" file, but you don't need to use it.


